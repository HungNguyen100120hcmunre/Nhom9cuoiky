# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from main1 import MainWindow2, Ui_Main
from PyQt5 import QtCore, QtGui, QtWidgets
import cv2
import os
import pyodbc
import numpy as np
from PIL import Image
import tensorflow as tf
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox
from tensorflow.keras.models import Model
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import AveragePooling2D
from tensorflow.keras.layers import MaxPooling2D
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.layers import Activation
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Input
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import concatenate
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.optimizers import SGD

class Ui_FaceRecogintion(object):
    check = False
    def setupUi(self, FaceRecogintion):
        FaceRecogintion.setObjectName("FaceRecogintion")
        FaceRecogintion.setEnabled(True)
        FaceRecogintion.resize(946, 647)
        FaceRecogintion.setMouseTracking(False)
        FaceRecogintion.setAutoFillBackground(True)
        FaceRecogintion.setStyleSheet("")
        FaceRecogintion.setAnimated(True)
        self.centralwidget = QtWidgets.QWidget(FaceRecogintion)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(390, 390, 231, 41))
        self.pushButton.setStyleSheet("background-color: rgb(98, 255, 0);")
        self.pushButton.setObjectName("pushButton")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(250, 270, 81, 41))
        self.label.setStyleSheet("color: rgb(255, 255, 255);")
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(250, 330, 71, 41))
        self.label_2.setStyleSheet("color: rgb(255, 255, 255);")
        self.label_2.setObjectName("label_2")
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(340, 270, 331, 41))
        self.lineEdit.setObjectName("lineEdit")
        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setGeometry(QtCore.QRect(340, 330, 331, 41))
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(380, 200, 241, 61))
        font = QtGui.QFont()
        font.setPointSize(20)
        self.label_3.setFont(font)
        self.label_3.setStyleSheet("color: rgb(255, 255, 255);")
        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.bg = QtWidgets.QLabel(self.centralwidget)
        self.bg.setEnabled(True)
        self.bg.setGeometry(QtCore.QRect(0, 0, 1001, 621))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.bg.sizePolicy().hasHeightForWidth())
        self.bg.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setStyleStrategy(QtGui.QFont.NoAntialias)
        self.bg.setFont(font)
        self.bg.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.bg.setAutoFillBackground(False)
        self.bg.setStyleSheet("background-color: rgb(0, 85, 127);")
        self.bg.setFrameShadow(QtWidgets.QFrame.Plain)
        self.bg.setText("")
        self.bg.setScaledContents(True)
        self.bg.setWordWrap(False)
        self.bg.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextEditable|QtCore.Qt.TextEditorInteraction|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)
        self.bg.setObjectName("bg")
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(10, 560, 171, 16))
        self.label_4.setStyleSheet("color: rgb(255, 255, 255);")
        self.label_4.setObjectName("label_4")
        self.bg.raise_()
        self.label.raise_()
        self.label_2.raise_()
        self.label_3.raise_()
        self.lineEdit_2.raise_()
        self.lineEdit.raise_()
        self.pushButton.raise_()
        self.label_4.raise_()
        FaceRecogintion.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(FaceRecogintion)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 946, 26))
        self.menubar.setObjectName("menubar")
        FaceRecogintion.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(FaceRecogintion)
        self.statusbar.setObjectName("statusbar")
        FaceRecogintion.setStatusBar(self.statusbar)

        self.retranslateUi(FaceRecogintion)
        QtCore.QMetaObject.connectSlotsByName(FaceRecogintion)
        self.pushButton.clicked.connect(self.login)

    def retranslateUi(self, FaceRecogintion):
        _translate = QtCore.QCoreApplication.translate
        FaceRecogintion.setWindowTitle(_translate("FaceRecogintion", "MainWindow"))
        self.pushButton.setText(_translate("FaceRecogintion", "Đăng nhập"))
        self.label.setText(_translate("FaceRecogintion", "Tài khoản"))
        self.label_2.setText(_translate("FaceRecogintion", "Mật khẩu"))
        self.label_3.setText(_translate("FaceRecogintion", "FORM LOGIN"))
        self.label_4.setText(_translate("FaceRecogintion", "Face Recognition | Group 9 "))


    #login vào ứng dụng
    def login(self):

        # Thiết lập thông tin kết nối
        server = 'localhost'
        database = 'cuoiki'
        username = 'sa'
        password = 'Tranlam1@!'

        user_ = str(self.lineEdit.text())
        pass_ = str(self.lineEdit_2.text())

        try:
            # Tạo chuỗi kết nối
            conn_str = f'DRIVER={{SQL Server}};SERVER={server};DATABASE={database};UID={username};PWD={password}'

            # Kết nối đến cơ sở dữ liệu
            conn = pyodbc.connect(conn_str)

            # Tạo một đối tượng cursor để thực thi các truy vấn SQL
            cursor = conn.cursor()
            # Truy vấn SQL để kiểm tra thông tin đăng nhập
            query = """
                    SELECT *
                    FROM login
                    WHERE username = ? AND password = ?
                    """
            cursor.execute(query, (user_, pass_))
            # Lấy dòng kết quả
            row = cursor.fetchone()

            if row:
                # check num data image
                if (row[2] < 20):
                    self.create_data(user_, pass_, row[3])
                else:
                    self.check(row[3], row[0])
                    #self.train(5)

            else:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setWindowTitle("Lỗi kết nối")
                msg.setText("Sai thông tin hoặc mật khẩu, vui lòng nhập lại")
                msg.exec_()

            # Đóng kết nối
            conn.close()

        except pyodbc.Error as ex:
            # In ra thông báo lỗi nếu kết nối không thành công
            # Tạo một hộp thoại thông báo
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setWindowTitle("Lỗi kết nối")
            msg.setText("Kết nối đến cơ sở dữ liệu thất bại rồi")
            msg.setInformativeText(str(ex))
            msg.exec_()

    #thu thập ảnh
    def create_data(self, user_, pass_, id_):
        import os
        import cv2
        import pyodbc
        id = 2
        if id == 2:
            cap = cv2.VideoCapture(0)
            detector = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
            sampleNum = 0
            while True:
                ret, frame = cap.read()
                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                fa = detector.detectMultiScale(gray, 1.1, 5)
                for (x, y, w, h) in fa:
                    cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
                cv2.imshow('frame', frame)
                # Chờ sự kiện nhấn phím
                key = cv2.waitKey(1)
                if key == ord('s'):  # Nhấn phím 's' để chụp ảnh
                    sampleNum += 1
                    if not os.path.exists('dataset2'):
                        os.makedirs('dataset2')
                    num_ = str(id_)
                    user_directory = os.path.join('dataset2', num_)
                    if not os.path.exists(user_directory):
                        os.makedirs(user_directory)
                    ret, frame1 = cap.read()
                    cv2.imwrite(f'{user_directory}/anh{1}.{sampleNum}.jpg', frame1)
                    print("Chụp ảnh số:", sampleNum)
                    if sampleNum > 19:
                        # Thiết lập thông tin kết nối
                        server = 'localhost'
                        database = 'cuoiki'
                        username = 'sa'
                        password = 'Tranlam1@!'
                        try:
                            # Tạo chuỗi kết nối
                            conn_str = f'DRIVER={{SQL Server}};SERVER={server};DATABASE={database};UID={username};PWD={password}'

                            # Kết nối đến cơ sở dữ liệu
                            conn = pyodbc.connect(conn_str)

                            # Tạo một đối tượng cursor để thực thi các truy vấn SQL
                            cursor = conn.cursor()
                            # Truy vấn SQL để kiểm tra thông tin đăng nhập
                            query = """
                                SELECT *
                                FROM login
                                WHERE username = ? AND password = ?
                            """
                            cursor.execute(query, (user_, pass_))
                            # Lấy dòng kết quả
                            row = cursor.fetchone()
                            if row:
                                # Cập nhật giá trị của dòng trong cơ sở dữ liệu
                                update_query = """
                                    UPDATE login
                                    SET data = ?
                                    WHERE username = ? AND password = ?
                                """
                                cursor.execute(update_query, (20, user_, pass_))
                                # Lưu thay đổi vào cơ sở dữ liệu
                                conn.commit()
                                print(id_)
                                self.train(id_)
                                cap.release()
                                cv2.destroyAllWindows()
                                return
                        except pyodbc.Error as ex:
                            # In ra thông báo lỗi nếu kết nối không thành công
                            print("Lỗi kết nối:", ex)
                            break
                # Thoát khỏi vòng lặp nếu nhấn phím 'q'
                elif key == ord('q'):
                    break
            cap.release()
            cv2.destroyAllWindows()

    def train(self, id_):
        import cv2
        import numpy as np
        from sklearn.preprocessing import LabelBinarizer
        from tensorflow.keras.models import Sequential
        from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Activation
        from tensorflow.keras.optimizers import Adam
        from sklearn.model_selection import train_test_split

        # ----convert-------

        id_int = int(id_)
        detector = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
        if not os.path.exists('dataset_end'):
            os.makedirs('dataset_end')


        for j in range(1, id_int + 1):
            value_ = str(j)
            user_directory = os.path.join('dataset_end', value_)
            if not os.path.exists(user_directory):
                os.makedirs(user_directory)

            for i in range(1, 21):

                filename = f'./dataset2/{j}/anh1.{i}.jpg'
                frame = cv2.imread(filename)
                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                fa = detector.detectMultiScale(gray, 1.1, 5)
                for (x, y, w, h) in fa:
                    cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
                    cv2.imwrite(f'{user_directory}/anh1.{i}.jpg', gray[y:y + h, x:x + w])

        # #-----Training
        data = []
        label = []

        for j in range(1, id_int + 1):
            for i in range(1, 21):
                filename = f'./dataset_end/{j}/anh1.{i}.jpg'
                print(filename)
                Img = cv2.imread(filename)
                Img = cv2.cvtColor(Img, cv2.COLOR_BGR2GRAY)
                Img = cv2.resize(src=Img, dsize=(100, 100))
                # Img = Img.reshape((100, 100, 1))
                Img = np.array(Img)

                data.append(Img)
                label.append(j - 1)
                print(filename)

        data1 = np.array(data)
        label = np.array(label)  # nhãn tương ứng với mỗi ảnh

        data1 = data1.reshape((id_int * 20, 100, 100, 1))
        X_train = data1 / 255
        from sklearn.preprocessing import LabelBinarizer
        lb = LabelBinarizer()
        trainY = lb.fit_transform(label)

        # Sử dụng kiến trúc mạng CNN Sequential API của Keras.
        # Bao gồm các lớp Convolutional, MaxPooling, Flatten và Dense.
        Model = Sequential()
        shape = (100, 100, 1)
        Model.add(Conv2D(32, (3, 3), padding="same", input_shape=shape))
        Model.add(Activation("relu"))
        Model.add(Conv2D(32, (3, 3), padding="same"))
        Model.add(Activation("relu"))
        Model.add(MaxPooling2D(pool_size=(2, 2)))
        Model.add(Conv2D(64, (3, 3), padding="same"))
        Model.add(Activation("relu"))
        Model.add(MaxPooling2D(pool_size=(2, 2)))
        Model.add(Flatten())
        Model.add(Dense(512))
        Model.add(Activation("relu"))
        Model.add(Dense(id_int))
        Model.add(Activation("softmax"))
        Model.summary()
        Model.compile(loss='categorical_crossentropy',
                      optimizer='adam',
                      metrics=['accuracy'])
        print("start training")
        Model.fit(X_train, trainY, batch_size=5, epochs=10)
        Model.save("face-result.h5")

    #kiem tra face sau khi login
    def check(self, id_, name_):
        main_window2 = MainWindow2()  # Tạo ra MainWindow2 ở đây
        main_window2.hide()
        isTrue = False
        cap = cv2.VideoCapture(cv2.CAP_DSHOW)
        detector = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

        while True:
            ret, frame = cap.read()
            if not ret:
                print("Failed to capture frame")
                break

            fa = detector.detectMultiScale(frame, 1.1, 5)

            # Draw rectangles around faces only when displaying the frame
            for (x, y, w, h) in fa:
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)

            # Display the frame
            cv2.imshow('frame', frame)

            # Wait for key event
            key = cv2.waitKey(1)

            # Press 's' to capture the image
            if key == ord('s'):
                ret, frame1 = cap.read()
                cv2.imwrite(f'test/test.jpg', frame1)
                break


            # Press 'q' to quit the application
            if key == ord('q'):
                break

        cap.release()
        cv2.destroyAllWindows()

    ##-------------
        filename = 'test/test.jpg'
        image = cv2.imread(filename)
        face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
        save_model = tf.keras.models.load_model("face-result.h5")
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        fa = face_cascade.detectMultiScale(gray, 1.1, 5)
        fontface = cv2.FONT_HERSHEY_SIMPLEX

        for (x, y, w, h) in fa:
            cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)
            roi_gray = gray[y:y + h, x:x + w]
            roi_gray = cv2.resize(src=roi_gray, dsize=(100, 100))
            roi_gray = roi_gray.reshape((100, 100, 1))
            roi_gray = np.array(roi_gray)
            result = save_model.predict(np.array([roi_gray]))
            final = np.argmax(result)

            if(final + 1 == id_):
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setWindowTitle("Thông báo")
                msg.setText("Nhận diện khuôn mặt thành công")
                msg.exec_()

                QtCore.QTimer.singleShot(100, lambda: main_window2.show())

                cv2.imshow('trainning', image)
                print(result)
                cv2.waitKey(0)


            else:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setWindowTitle("Thông báo")
                msg.setText("Nhận diện khuôn mặt thất bại")
                msg.exec_()
                cv2.imshow('trainning', image)
                print(result)


class MainWindow1(QMainWindow):
    def __init__(self):
        super().__init__()

        self.main_window2 = MainWindow2()
        self.main_window2.show()

class MainWindow2(QMainWindow):
    def __init__(self):
        super().__init__()
        self.ui = Ui_Main()
        self.ui.setupUi(self)

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    FaceRecogintion = QtWidgets.QMainWindow()
    ui = Ui_FaceRecogintion()
    ui.setupUi(FaceRecogintion)
    FaceRecogintion.show()


    sys.exit(app.exec_())
